package reset

import (
	"fmt"
	"slices"
	"strings"

	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"unicode"
)

// Field - структура для хранения информации о полях структуры.
type Field struct {
	Name string
	Type string
}

// NewField возвращает указатель на новый экземпляр Field.
func NewField(name, t string) *Field {
	return &Field{
		Name: name,
		Type: t,
	}
}

// GeneratedStruct - структура для хранения информации о структуре.
type GeneratedStruct struct {
	Name      string
	Alias     string
	LineStart int
	Fields    []Field
}

// NewGenerateStruct - функция для создания новой структуры GeneratedStruct.
func NewGenerateStruct(name string, lineStart int) *GeneratedStruct {
	return &GeneratedStruct{
		Name:      name,
		LineStart: lineStart,
		Fields:    make([]Field, 0),
	}
}

// LowerFirstRune возвращает первый символ строки в нижнем регистре.
func (g *GeneratedStruct) lowerFirstRune() {
	runes := []rune(g.Name)
	if len(runes) != 0 {
		g.Alias = string(unicode.ToLower(runes[0]))
	}
}

// parseComments - функция для извлечения информации о комментариях.
func parseComments(fset *token.FileSet, file *ast.File) []int {
	linesResetComment := make([]int, 5)

	for _, gr := range file.Comments {
		for _, c := range gr.List {
			if strings.Contains(c.Text, "generate:reset") {
				linesResetComment = append(linesResetComment, fset.Position(c.Slash).Line)
			}
		}
	}
	return linesResetComment
}

// fillingResetMethod - функция для заполнения метода Reset.
func fillingResetMethod(fields []Field, sb *strings.Builder, alias, name string) {
	fmt.Fprintf(sb, "if %s == nil {return}\n", alias)
	for _, field := range fields {
		switch {
		case field.Type == "int":
			fmt.Fprintf(sb, "%s.%s = 0\n", alias, field.Name)
		case field.Type == "string":
			fmt.Fprintf(sb, "%s.%s = \"\"\n", alias, field.Name)
		case strings.Contains(field.Type, "map"):
			fmt.Fprintf(sb, "clear(%s.%s)\n", alias, field.Name)
		case strings.Contains(field.Type, "[]"):
			fmt.Fprintf(sb, "%s.%s = %s.%s[:0]\n", alias, field.Name, alias, field.Name)
		case strings.Contains(field.Type, "*int"):
			fmt.Fprintf(sb, "if %s.%s != nil {*%s.%s = 0}\n", alias, field.Name, alias, field.Name)
		case strings.Contains(field.Type, "*string"):
			fmt.Fprintf(sb, "if %s.%s != nil {*%s.%s = \"\"}\n", alias, field.Name, alias, field.Name)
		case field.Type == "*"+name:
			fmt.Fprintf(sb, "if resetter, ok := %s.%s.(interface{ Reset() }); ok && %s.%s != nil {resetter.Reset()\n}", alias, field.Name, alias, field.Name)
		}
	}
}

// GenerateReset - функция для генерации кода.
func parsePackage(dir []*ast.File, fset *token.FileSet, path string) {
	var (
		buf             bytes.Buffer
		sb              strings.Builder
		packageName     string
		arrResetStructs []*GeneratedStruct
		structName      string
		structLineStart int
		space           = []byte(" ")
		err             error
	)

	for _, file := range dir {
		linesResetComment := parseComments(fset, file)

		if len(linesResetComment) == 0 {
			continue
		}

		// вынести в отдельную функцию
		ast.Inspect(file, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.File:
				packageName = x.Name.Name
			case *ast.TypeSpec:
				switch s := x.Type.(type) {
				case *ast.StructType:
					structName = x.Name.Name
					structLineStart = fset.Position(x.Pos()).Line
					structFields := s.Fields.List
					if len(structFields) == 0 {
						return false
					}
					for _, f := range structFields {
						if len(f.Names) == 0 {
							return false
						}
						err = printer.Fprint(&buf, fset, f.Names[0])
						if err != nil {
							return false
						}
						buf.Write(space)
						err = printer.Fprint(&buf, fset, f.Type)
						if err != nil {
							return false
						}
						buf.Write(space)
					}
				}

				if structName != "" && slices.Contains(linesResetComment, structLineStart-1) {
					genStruct := NewGenerateStruct(structName, structLineStart)
					genStruct.lowerFirstRune()

					s := buf.String()
					d := strings.Fields(s)

					for i := 0; i < len(d); i += 2 {
						ff := NewField(d[i], d[i+1])
						genStruct.Fields = append(genStruct.Fields, *ff)
					}
					arrResetStructs = append(arrResetStructs, genStruct)
				}
				structName = ""
				structLineStart = 0
			}
			return true
		})
	}

	if len(arrResetStructs) > 0 {
		fmt.Fprintf(&sb, "%s %s\n\n", `
		// Code generated by go generate; DO NOT EDIT.
		// This file was generated by my_test_file.go

		package`, packageName)

		for _, s := range arrResetStructs {
			fmt.Fprintf(&sb, "func (%s *%s) Reset() {\n", s.Alias, s.Name)
			fillingResetMethod(s.Fields, &sb, s.Alias, s.Name)
			fmt.Fprintf(&sb, "}\n")
		}

		generated := []byte(sb.String())
		formatted, err := format.Source(generated)
		if err != nil {
			panic(err)
		}
		pathToFile := filepath.Join(path, "reset.gen.go")
		err = os.WriteFile(pathToFile, formatted, 0644)
		if err != nil {
			panic(err)
		}
	}
}

// App - функция для запуска приложения.
func App() error {
	root := "."
	fset := token.NewFileSet()

	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() {
			return nil
		}

		pkgs, err := parser.ParseDir(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		for _, pkg := range pkgs {
			var files []*ast.File
			for _, f := range pkg.Files {
				files = append(files, f)
			}
			parsePackage(files, fset, path)
		}
		return nil
	})

	if err != nil {
		return err
	}
	return nil
}
